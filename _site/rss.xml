<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Programming Historian</title>
		<description>Introductory and intermediate programming lessons for humanists</description>
		<link>http://programminghistorian.org</link>
		<atom:link href="http://programminghistorian.org/rss.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>How We Moved the Programming Historian to GitHub Pages</title>
				<description>&lt;p&gt;Earlier this year, the editors of The Programming Historian decided to move the site from a Wordpress installation to a &lt;a href=&quot;http://en.wikipedia.org/wiki/Static_web_page&quot;&gt;static website&lt;/a&gt; hosted on &lt;a href=&quot;http://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;. This post is a brief overview of how we made the switch, using some of the same tools and computational methods featured in our lessons.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to focus on how we converted the HTML pages generated by our Wordpress site into Markdown files that were ready to be deployed on GitHub. In the process, I&amp;rsquo;ll show how it&amp;rsquo;s possible to build on a series of Programming Historian lessons to solve new problems. Be aware, however, that this post will be slightly more technical than our usual lessons; it may be most beneficial for readers who are already comfortable using command line tools like Pandoc and are contemplating a similar conversion for their Wordpress website.&lt;/p&gt;

&lt;p&gt;Our new website uses a publishing platform called &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; to turn a repository of files written in &lt;a href=&quot;https://help.github.com/articles/markdown-basics&quot;&gt;Markdown&lt;/a&gt; into an HTML website. In the case of the Programming Historian, Jekyll uses &lt;a href=&quot;https://github.com/programminghistorian/jekyll&quot;&gt;this repository&lt;/a&gt; to generate &lt;a href=&quot;http://programminghistorian.org&quot;&gt;this website&lt;/a&gt;. Lessons that look like &lt;a href=&quot;https://raw.githubusercontent.com/programminghistorian/jekyll/gh-pages/lessons/data-mining-the-internet-archive.md&quot;&gt;this&lt;/a&gt; are converted by Jekyll into lessons that look like &lt;a href=&quot;http://programminghistorian.org/lessons/data-mining-the-internet-archive&quot;&gt;that&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to the power of Jekyll, generating our new website was easy once all of our lessons and pages were formatted correctly in Markdown. Our challenge was to get all of the HTML pages from the Wordpress site and convert them into Markdown that Jekyll could understand. This was a multi-stage process made easier by tools like Wget, Pandoc, and Python.&lt;/p&gt;

&lt;h2 id=&quot;downloading-the-old-site-with-wget&quot;&gt;Downloading the Old Site with Wget&lt;/h2&gt;

&lt;p&gt;Our first step was to get HTML versions of all the pages and lessons on our old site. To do this, we used the &lt;code&gt;wget&lt;/code&gt; tool described by Ian Milligan in &lt;a href=&quot;http://programminghistorian.org/lessons/automated-downloading-with-wget&quot;&gt;Automated Downloading with Wget&lt;/a&gt;. Applying that lesson to our particular problem, we were able to download all the &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/master/original_html&quot;&gt;original HTML pages&lt;/a&gt; from our Wordpress site. (Note that these original HTML pages, as well as most of the scripts described below, reside on the &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/master&quot;&gt;master branch&lt;/a&gt; of our GitHub repository. The live, current site resides on the default &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/gh-pages&quot;&gt;gh-pages branch&lt;/a&gt;.)&lt;/p&gt;

&lt;h2 id=&quot;preparing-the-old-html-for-pandoc-conversion&quot;&gt;Preparing the Old HTML for Pandoc Conversion&lt;/h2&gt;

&lt;p&gt;For the next step&amp;mdash;the conversion of these HTML files to Markdown&amp;mdash;we decided to use &lt;a href=&quot;http://johnmacfarlane.net/pandoc/&quot;&gt;Pandoc&lt;/a&gt;, a powerful tool described by Dennis Tenen and Grant Wythoff in &lt;a href=&quot;http://programminghistorian.org/lessons/sustainable-authorship-in-plain-text-using-pandoc-and-markdown&quot;&gt;Sustainable Authorship in Plain Text using Pandoc and Markdown&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That lesson focuses on using Pandoc to convert from Markdown into other formats, but Pandoc is also able to turn HTML to Markdown, which is what we wanted to do. It can even locate metadata in the HTML, such as the author, title, and date, and convert it into a &lt;a href=&quot;http://jekyllrb.com/docs/frontmatter/&quot;&gt;YAML metadata block&lt;/a&gt; in the Markdown output that Jekyll will recognize.&lt;/p&gt;

&lt;p&gt;But Pandoc needs some help to do this. For example, it expects to find metadata in &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags that look like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Caleb McDaniel&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;author&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Data Mining the Internet Archive Collection&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;03-03-2014&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;date&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;William J Turkel&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;reviewers&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And if you want Pandoc to put that information into a YAML block when converting to Markdown, then those tags have to be located between the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;/head&amp;gt;&lt;/code&gt; tags of the HTML document. &lt;/p&gt;

&lt;p&gt;This deepened our challenge, however, because our original HTML files did not place metadata like author and title inside &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags. Here&amp;rsquo;s an example of how the metadata above appeared in the &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/original_html/data-mining-the-internet-archive.html&quot;&gt;original HTML&lt;/a&gt; downloaded from our Wordpress site:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;article&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;header&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;kicker&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;March 3, 2014&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://programminghistorian.org/lessons/data-mining-the-internet-archive&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Data Mining the Internet Archive Collection&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;byline&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;By Caleb McDaniel&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;credits&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;technical-reviewer&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Technical Reviewer: William J Turkel&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, before we could use Pandoc to convert that HTML to Markdown, we needed to modify the HTML to look more like the &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; examples above. And to do that, we used a Python library called Beautiful Soup, which was explained by Jeri Wieringa in her lesson, &lt;a href=&quot;http://programminghistorian.org/lessons/intro-to-beautiful-soup&quot;&gt;Intro to Beautiful Soup&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In that lesson, Wieringa focused on the power of Beautiful Soup to &amp;ldquo;pull particular content from a webpage&amp;rdquo; by extracting it from particular tags. In the example above, we could use a snippet of code that looks something like this to get the content of the &lt;code&gt;&amp;lt;p class=&amp;quot;byline&amp;quot;&amp;gt;By Caleb McDaniel&amp;lt;/p&amp;gt;&lt;/code&gt; tag:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;soup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeautifulSoup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;soup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;class_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;byline&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Note that this code snippet assumes we have already used the standard Python techniques for &lt;a href=&quot;http://programminghistorian.org/lessons/working-with-text-files#reading-from-a-text-file&quot;&gt;reading from a text file&lt;/a&gt; to get our original HTML from a file and assign it to the variable &lt;code&gt;html&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Beautiful Soup can do more than just help us to &lt;em&gt;find&lt;/em&gt; content in HTML, however; it can also be used to modify the HTML tree. For example, a code snippet that looks something like the below would (1) save all the content from the original &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tag, (2) create a new &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tag that contains the content from our &lt;code&gt;author&lt;/code&gt; variable, but with the leading &lt;code&gt;By&lt;/code&gt; stripped out; and (3) insert that new &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tag into the original &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tag:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;original_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;soup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;author_tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;soup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;meta&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;author_tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;author&amp;#39;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;author_tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;content&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lstrip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;By &amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;original_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;author_tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can follow a similar two-step procedure (find the metadata in the original HTML, and then move it to a tag where Pandoc will be able to recognize it &lt;em&gt;as&lt;/em&gt; metadata) to modify the way that the lesson date, reviewers, and title are stored in the HTML document. We also can and did use Beautiful Soup to make other modifications to the HTML in preparation for Pandoc conversion, such as locating and discarding (or &amp;ldquo;decomposing,&amp;rdquo; in the language of Beautiful Soup) the comments section on old posts.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/prep_for_pandoc.py&quot;&gt;This script&lt;/a&gt; shows all the changes we eventually made in this way. (See the comment lines to get a sense of what each part of the script does.) After running that script on our folder of &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/master/original_html&quot;&gt;original HTML&lt;/a&gt; pages downloaded from our Wordpress site, we had a new folder of &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/master/modified_html&quot;&gt;modified HTML files&lt;/a&gt; that was ready (or at least readier) to be fed into Pandoc for conversion into Markdown files.&lt;/p&gt;

&lt;h2 id=&quot;converting-our-modified-html-to-markdown&quot;&gt;Converting Our Modified HTML to Markdown&lt;/h2&gt;

&lt;p&gt;Pandoc can convert an HTML file to Markdown with one simple command:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pandoc -f html -t markdown data-mining-the-internet-archive.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But in our case, the conversion was not quite so simple. Consider what happens if you run that command on &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/modified_html/data-mining-the-internet-archive.html&quot;&gt;one of our modified HTML files&lt;/a&gt;. You would get a Markdown file that begins like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Lesson Goals
------------

The collections of the [Internet Archive](http://archive.org/) (IA)
include many digitized sources of interest to historians, including
[early JSTOR journal content](https://archive.org/details/jstor_ejc),
[John Adams&amp;#39;s personal
library](https://archive.org/details/johnadamsBPL), and the [Haiti
collection](https://archive.org/details/jcbhaiti) at the John Carter
Brown Library. In short, to quote Programming Historian [Ian
Milligan](http://activehistory.ca/2013/09/the-internet-archive-rocks-or-two-million-plus-free-sources-to-explore/),
&amp;quot;The Internet Archive rocks.&amp;quot;

In this lesson, you&amp;#39;ll learn how to download files from such collections
using a Python module specifically designed for the Internet Archive.
You will also learn how to use another Python module designed for
parsing MARC XML records, a widely used standard for formatting
bibliographic metadata.

For demonstration purposes, this lesson will focus on working with the
digitized version of the [Anti-Slavery
Collection](http://archive.org/details/bplscas) at the Boston Public
Library in Copley Square. We will first download a large collection of
MARC records from this collection, and then use Python to retrieve and
analyze bibliographic information about items in the collection. For
example, by the end of this lesson, you will be able to create a list of
every named place from which a letter in the antislavery collection was
written, which you could then use for a mapping project or some other
kind of analysis.

For Whom Is This Useful?
------------------------

This intermediate lesson is good for users of the Programming Historian
who have completed general lessons on downloading files and performing
text analysis on them, but would like an applied example of these
principles. It will also be of interest to historians or archivists who
work with the MARC format or the Internet Archive on a regular basis.

Before You Begin
----------------

We will be working with two Python modules that are not included in
Python&amp;#39;s standard library.

The first,
[internetarchive](https://pypi.python.org/pypi/internetarchive),
provides programmatic access to the Internet Archive. The second,
[pymarc](https://pypi.python.org/pypi/pymarc/), makes it easier to parse
MARC records.

The easiest way to download both is to use pip, the python package
manager. Begin by installing pip using [this Programming Historian
lesson](http://programminghistorian.org/lessons/installing-python-modules-pip/).
Then issue these commands at the command line: To install
internetarchive:

``` {.bash}
sudo pip install internetarchive
```

To install pymarc:

``` {.bash}
sudo pip install pymarc
```

Now you are ready to go to work!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pandoc has converted our links and codeblocks into Markdown syntax, and eliminated a lot of the unnecessary content from the beginning of our HTML file. But right away, we can notice two things that make this Markdown conversion imperfect. First, despite all the work that we did to capture the author, title, and date from the original HTML, that metadata does not appear in this output.&lt;/p&gt;

&lt;p&gt;A less obvious problem appears in the way that Pandoc has rendered code blocks&amp;mdash;by surrounding the code with two lines of three backticks, the first of which also contains the language in curly braces. This is what Pandoc calls a &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#fenced-code-blocks&quot;&gt;fenced code block&lt;/a&gt;. Its purpose is to allow keywords in the code to be highlighted with appropriate colors, as you can see in many Programming Historian lessons. But Jekyll, the engine that powers GitHub Pages, does not recognize fenced code blocks that are formatted in this way.&lt;/p&gt;

&lt;p&gt;There are actually other, even &lt;em&gt;less&lt;/em&gt; obvious problems with the default Markdown conversion that Pandoc produced, but I&amp;rsquo;ll focus on these two. The fixes for them illustrate Pandoc&amp;rsquo;s power and the general principles we used to improve our bulk conversion workflow.&lt;/p&gt;

&lt;h3 id=&quot;preserving-document-metadata&quot;&gt;Preserving Document Metadata&lt;/h3&gt;

&lt;p&gt;First, let&amp;rsquo;s consider the lack of metadata in our Markdown output. Recall that we did a lot of work with Beautiful Soup to create &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags for title, reviewer, author, and date. We hoped that Pandoc would pick up that information from the modified HTML and put into our converted Markdown file, ideally as a YAML front matter block that could be recognized by Jekyll. So what happened?&lt;/p&gt;

&lt;p&gt;The short answer is that we needed to add two more things to our Pandoc command. The first is the &lt;code&gt;--standalone&lt;/code&gt; option, which is described on the &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html&quot;&gt;Pandoc User&amp;rsquo;s Guide&lt;/a&gt; page.&lt;/p&gt;

&lt;p&gt;By default, Pandoc outputs &amp;ldquo;snippets&amp;rdquo;; it focuses on converting the input text into the output format. In most cases, the metadata of the original document doesn&amp;rsquo;t affect that conversion, so Pandoc simply ignores it. In the case of HTML, Pandoc&amp;rsquo;s default behavior is to convert what is between the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tags into your desired output format, and simply ignore what was between the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;

&lt;p&gt;One of the things that the &lt;code&gt;--standalone&lt;/code&gt; option does is to override that default, and instead capture any header and metadata information so that it can be put into the output document. So we should have run this Pandoc command instead of the one above:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pandoc -f html -t markdown --standalone data-mining-the-internet-archive.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At first glance, it still won&amp;rsquo;t look like that command made a difference. You&amp;rsquo;ll get what seems to be the same Markdown output, with no metadata.&lt;/p&gt;

&lt;p&gt;Behind the scenes, however, Pandoc is grabbing the metadata we stored in our &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags and assigning them to Pandoc template variables based on the &lt;code&gt;name&lt;/code&gt; attribute of these tags: for example, &lt;code&gt;author&lt;/code&gt;, &lt;code&gt;reviewers&lt;/code&gt;, and &lt;code&gt;title&lt;/code&gt;. (If you really want to understand what&amp;rsquo;s going on under the hood, try running the above command, with and without the &lt;code&gt;--standalone&lt;/code&gt; option, but changing &lt;code&gt;-t markdown&lt;/code&gt; to &lt;code&gt;-t native&lt;/code&gt;. Even without understanding the output you see, you can compare the first lines of the native output for a standalone document with the first lines of output without the standalone option. Notice that with standalone, something that looks like our metadata appears in the native output.)&lt;/p&gt;

&lt;p&gt;In short, &lt;code&gt;--standalone&lt;/code&gt; has captured the metadata we wanted and assigned it to variables. but we also need to tell Pandoc &lt;em&gt;where&lt;/em&gt; to &lt;em&gt;put&lt;/em&gt; that metadata in our output. To do that, we used a &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#templates&quot;&gt;custom Pandoc template&lt;/a&gt; that looked like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;---
title: $title$
author: $for(author)$$author$$sep$, $endfor$
date: $date$
reviewers: $reviewers$
---

$body$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can read more about &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#templates&quot;&gt;templates&lt;/a&gt; in the Pandoc documentation, but the important thing to note here is that we are telling Pandoc where to output our metadata variables (represented by words with dollar signs around them, like &lt;code&gt;$title$&lt;/code&gt;) and where to output the main body of the HTML file (represented by the &lt;code&gt;$body$&lt;/code&gt; variable). The words that are not wrapped in dollar signs in our template will pass literally into our output document. &lt;/p&gt;

&lt;p&gt;We can save that template in a file called &lt;code&gt;jekyll.md&lt;/code&gt; and then add the option &lt;code&gt;--template=jekyll.md&lt;/code&gt; to our Pandoc command above, like so:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pandoc -f html -t markdown --standalone --template=jekyll.md data-mining-the-internet-archive.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we do, the start of our Markdown output should now look like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;---
title: Data Mining the Internet Archive Collection
author: Caleb McDaniel
date: 03-03-2014
reviewers: William J Turkel
---

Lesson Goals
------------

The collections of the [Internet Archive](http://archive.org/) (IA)
include many digitized sources of interest to historians, including
[early JSTOR journal content](https://archive.org/details/jstor_ejc),
[John Adams&amp;#39;s personal
library](https://archive.org/details/johnadamsBPL), and the [Haiti
collection](https://archive.org/details/jcbhaiti) at the John Carter
Brown Library. In short, to quote Programming Historian [Ian
Milligan](http://activehistory.ca/2013/09/the-internet-archive-rocks-or-two-million-plus-free-sources-to-explore/),
&amp;quot;The Internet Archive rocks.&amp;quot;

In this lesson, you&amp;#39;ll learn how to download files from such collections
using a Python module specifically designed for the Internet Archive.
You will also learn how to use another Python module designed for
parsing MARC XML records, a widely used standard for formatting
bibliographic metadata.

For demonstration purposes, this lesson will focus on working with the
digitized version of the [Anti-Slavery
Collection](http://archive.org/details/bplscas) at the Boston Public
Library in Copley Square. We will first download a large collection of
MARC records from this collection, and then use Python to retrieve and
analyze bibliographic information about items in the collection. For
example, by the end of this lesson, you will be able to create a list of
every named place from which a letter in the antislavery collection was
written, which you could then use for a mapping project or some other
kind of analysis.

For Whom Is This Useful?
------------------------

This intermediate lesson is good for users of the Programming Historian
who have completed general lessons on downloading files and performing
text analysis on them, but would like an applied example of these
principles. It will also be of interest to historians or archivists who
work with the MARC format or the Internet Archive on a regular basis.

Before You Begin
----------------

We will be working with two Python modules that are not included in
Python&amp;#39;s standard library.

The first,
[internetarchive](https://pypi.python.org/pypi/internetarchive),
provides programmatic access to the Internet Archive. The second,
[pymarc](https://pypi.python.org/pypi/pymarc/), makes it easier to parse
MARC records.

The easiest way to download both is to use pip, the python package
manager. Begin by installing pip using [this Programming Historian
lesson](http://programminghistorian.org/lessons/installing-python-modules-pip/).
Then issue these commands at the command line: To install
internetarchive:

``` {.bash}
sudo pip install internetarchive
```

To install pymarc:

``` {.bash}
sudo pip install pymarc
```

Now you are ready to go to work!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that our metadata is now inserted in the output as a &lt;a href=&quot;http://jekyllrb.com/docs/frontmatter/&quot;&gt;Jekyll metadata block&lt;/a&gt;. Hooray!&lt;/p&gt;

&lt;h3 id=&quot;converting-code-block-syntax&quot;&gt;Converting Code Block Syntax&lt;/h3&gt;

&lt;p&gt;The other problem we identified with our Markdown output&amp;mdash;the way to mark fenced code blocks&amp;mdash;remains to be solved, however. This problem was a bit trickier to solve, because Jekyll&amp;rsquo;s default Markdown parser does not recognize code blocks fenced with backticks at all. But &lt;a href=&quot;https://github.com/programminghistorian/jekyll/issues/2&quot;&gt;after some experimentation&lt;/a&gt;, we discovered that we could configure Jekyll to recognize and highlight code blocks that look like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;``` bash
sudo pip install pymarc
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pandoc, as we&amp;rsquo;ve seen, was wrapping &lt;code&gt;bash&lt;/code&gt; in curly braces and a period, like so: &lt;code&gt;{.bash}&lt;/code&gt;. That&amp;rsquo;s because by default, Pandoc is taking the &lt;code&gt;class&lt;/code&gt; attribute in &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/modified_html/data-mining-the-internet-archive.html#L50&quot;&gt;this line&lt;/a&gt; of our HTML and then putting it in braces. If there were more than one &lt;code&gt;class&lt;/code&gt; attribute in that line, Pandoc would continue putting them, prefaced by a period, inside those curly braces, as described in &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#fenced-code-blocks&quot;&gt;the documentation&lt;/a&gt; under &lt;code&gt;Extension: fenced_code_attributes&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;Fortunately, in this case we have a simpler solution than before, because Pandoc provides a command-line option for turning off this behavior. And once that behavior&amp;mdash;or &amp;ldquo;extension&amp;rdquo;&amp;mdash;is turned off, the documentation tells us what will happen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the &lt;code&gt;fenced_code_attributes&lt;/code&gt; extension is disabled, but input contains class attribute(s) for the codeblock, the first class attribute will be printed after the opening fence as a bare word.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In plainer English, that&amp;rsquo;s exactly what we want to produce fenced code blocks that Jekyll can, with some configuration, recognize! So, following the documentation for &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#general-options&quot;&gt;Pandoc&amp;rsquo;s general options&lt;/a&gt;, we modified our Pandoc command again to disable the &lt;code&gt;fenced_code_attributes&lt;/code&gt; extension, like so:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pandoc -f html -t markdown-fenced_code_attributes --standalone --template=jekyll.md data-mining-the-internet-archive.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Run that command on the same &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/modified_html/data-mining-the-internet-archive.html&quot;&gt;modified HTML file&lt;/a&gt; we&amp;rsquo;ve been using above, and the new Markdown output should begin like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;---
title: Data Mining the Internet Archive Collection
author: Caleb McDaniel
date: 03-03-2014
reviewers: William J Turkel
---

Lesson Goals
------------

The collections of the [Internet Archive](http://archive.org/) (IA)
include many digitized sources of interest to historians, including
[early JSTOR journal content](https://archive.org/details/jstor_ejc),
[John Adams’s personal
library](https://archive.org/details/johnadamsBPL), and the [Haiti
collection](https://archive.org/details/jcbhaiti) at the John Carter
Brown Library. In short, to quote Programming Historian [Ian
Milligan](http://activehistory.ca/2013/09/the-internet-archive-rocks-or-two-million-plus-free-sources-to-explore/),
“The Internet Archive rocks.”

In this lesson, you’ll learn how to download files from such collections
using a Python module specifically designed for the Internet Archive.
You will also learn how to use another Python module designed for
parsing MARC XML records, a widely used standard for formatting
bibliographic metadata.

For demonstration purposes, this lesson will focus on working with the
digitized version of the [Anti-Slavery
Collection](http://archive.org/details/bplscas) at the Boston Public
Library in Copley Square. We will first download a large collection of
MARC records from this collection, and then use Python to retrieve and
analyze bibliographic information about items in the collection. For
example, by the end of this lesson, you will be able to create a list of
every named place from which a letter in the antislavery collection was
written, which you could then use for a mapping project or some other
kind of analysis.

For Whom Is This Useful?
------------------------

This intermediate lesson is good for users of the Programming Historian
who have completed general lessons on downloading files and performing
text analysis on them, but would like an applied example of these
principles. It will also be of interest to historians or archivists who
work with the MARC format or the Internet Archive on a regular basis.

Before You Begin
----------------

We will be working with two Python modules that are not included in
Python’s standard library.

The first,
[internetarchive](https://pypi.python.org/pypi/internetarchive),
provides programmatic access to the Internet Archive. The second,
[pymarc](https://pypi.python.org/pypi/pymarc/), makes it easier to parse
MARC records.

The easiest way to download both is to use pip, the python package
manager. Begin by installing pip using [this Programming Historian
lesson](http://programminghistorian.org/lessons/installing-python-modules-pip/).
Then issue these commands at the command line: To install
internetarchive:

``` bash
sudo pip install internetarchive
```

To install pymarc:

``` bash
sudo pip install pymarc
```

Now you are ready to go to work!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice the difference in the way the two &lt;code&gt;bash&lt;/code&gt; code blocks at the end of that snippet are now formatted. We did it!&lt;/p&gt;

&lt;h2 id=&quot;completing-the-bulk-conversion-from-wordpress&quot;&gt;Completing the Bulk Conversion from Wordpress&lt;/h2&gt;

&lt;p&gt;In the above sections, I&amp;rsquo;ve scratched the surface of what was, even with the help of Pandoc, a big job. In the examples above, we&amp;rsquo;ve looked at only one brief section of &lt;em&gt;one&lt;/em&gt; lesson, and other lessons presented us with new challenges to solve. Making sure that all of our converted Markdown got close to the Markdown that Jekyll required took lots of &lt;a href=&quot;https://github.com/programminghistorian/jekyll/commits/master/lessons&quot;&gt;trial and error&lt;/a&gt; of the sort I&amp;rsquo;ve described. Other Pandoc options had to be enabled or disabled to get our Markdown to look just right, as you can see from &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/process_with_pandoc.sh&quot;&gt;the final script we used to process all of our modified HTML files with Pandoc&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We even used &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/pandoc_filter.py&quot;&gt;this Python filter&lt;/a&gt; to convert some of the URL paths in our original Markdown to relative paths, which were more suitable for our static website. (Pandoc filters, one of the most powerful ways of extending Pandoc, are described in more detail &lt;a href=&quot;http://johnmacfarlane.net/pandoc/scripting.html&quot;&gt;here&lt;/a&gt;. The problem that they solved in this case could also have been solved with further Beautiful Soup modifications to our original HTML. But the advantage of the filter is that it can be used in the future if we want to change relative links again in all our Markdown lessons.) &lt;/p&gt;

&lt;p&gt;After all that, our bulk conversion process still did not produce pristine Markdown at a single stroke. &lt;a href=&quot;https://github.com/programminghistorian/jekyll/issues/5&quot;&gt;Some of the markup in the original Wordpress site was irretrievably lost&lt;/a&gt; by the conversion process, while other errors in the Markdown had to be &lt;a href=&quot;https://github.com/programminghistorian/jekyll/issues/15&quot;&gt;corrected manually by our editors&lt;/a&gt;. One lesson we learned from the whole process is that there may be no such thing as a &lt;em&gt;totally automated&lt;/em&gt; workflow for converting from a Wordpress site like ours to a Jekyll static site.&lt;/p&gt;

&lt;p&gt;Nonetheless, software like Pandoc and techniques like those taught in our lessons on Wget and Beautiful Soup made a difficult job somewhat easier. The results are now available for you to enjoy on our &lt;a href=&quot;https://github.com/programminghistorian/jekyll&quot;&gt;GitHub Pages static site&lt;/a&gt;. Happy hacking!&lt;/p&gt;
</description>
				<pubDate>Wed, 05 Nov 2014 00:00:00 -0800</pubDate>
				<link>http://programminghistorian.org/jekyll/posts/how-we-moved-to-github</link>
				<guid isPermaLink="true">http://programminghistorian.org/jekyll/posts/how-we-moved-to-github</guid>
			</item>
		
			<item>
				<title>How We Moved the Programming Historian to GitHub Pages</title>
				<description>&lt;p&gt;Earlier this year, the editors of The Programming Historian decided to move the site from a Wordpress installation to a &lt;a href=&quot;http://en.wikipedia.org/wiki/Static_web_page&quot;&gt;static website&lt;/a&gt; hosted on &lt;a href=&quot;http://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;. This post is a brief overview of how we made the switch, using some of the same tools and computational methods featured in our lessons.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to focus on how we converted the HTML pages generated by our Wordpress site into Markdown files that were ready to be deployed on GitHub. In the process, I&amp;rsquo;ll show how it&amp;rsquo;s possible to build on a series of Programming Historian lessons to solve new problems. Be aware, however, that this post will be slightly more technical than our usual lessons; it may be most beneficial for readers who are already comfortable using command line tools like Pandoc and are contemplating a similar conversion for their Wordpress website.&lt;/p&gt;

&lt;p&gt;Our new website uses a publishing platform called &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; to turn a repository of files written in &lt;a href=&quot;https://help.github.com/articles/markdown-basics&quot;&gt;Markdown&lt;/a&gt; into an HTML website. In the case of the Programming Historian, Jekyll uses &lt;a href=&quot;https://github.com/programminghistorian/jekyll&quot;&gt;this repository&lt;/a&gt; to generate &lt;a href=&quot;http://programminghistorian.org&quot;&gt;this website&lt;/a&gt;. Lessons that look like &lt;a href=&quot;https://raw.githubusercontent.com/programminghistorian/jekyll/gh-pages/lessons/data-mining-the-internet-archive.md&quot;&gt;this&lt;/a&gt; are converted by Jekyll into lessons that look like &lt;a href=&quot;http://programminghistorian.org/lessons/data-mining-the-internet-archive&quot;&gt;that&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to the power of Jekyll, generating our new website was easy once all of our lessons and pages were formatted correctly in Markdown. Our challenge was to get all of the HTML pages from the Wordpress site and convert them into Markdown that Jekyll could understand. This was a multi-stage process made easier by tools like Wget, Pandoc, and Python.&lt;/p&gt;

&lt;h2 id=&quot;downloading-the-old-site-with-wget&quot;&gt;Downloading the Old Site with Wget&lt;/h2&gt;

&lt;p&gt;Our first step was to get HTML versions of all the pages and lessons on our old site. To do this, we used the &lt;code&gt;wget&lt;/code&gt; tool described by Ian Milligan in &lt;a href=&quot;http://programminghistorian.org/lessons/automated-downloading-with-wget&quot;&gt;Automated Downloading with Wget&lt;/a&gt;. Applying that lesson to our particular problem, we were able to download all the &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/master/original_html&quot;&gt;original HTML pages&lt;/a&gt; from our Wordpress site. (Note that these original HTML pages, as well as most of the scripts described below, reside on the &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/master&quot;&gt;master branch&lt;/a&gt; of our GitHub repository. The live, current site resides on the default &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/gh-pages&quot;&gt;gh-pages branch&lt;/a&gt;.)&lt;/p&gt;

&lt;h2 id=&quot;preparing-the-old-html-for-pandoc-conversion&quot;&gt;Preparing the Old HTML for Pandoc Conversion&lt;/h2&gt;

&lt;p&gt;For the next step&amp;mdash;the conversion of these HTML files to Markdown&amp;mdash;we decided to use &lt;a href=&quot;http://johnmacfarlane.net/pandoc/&quot;&gt;Pandoc&lt;/a&gt;, a powerful tool described by Dennis Tenen and Grant Wythoff in &lt;a href=&quot;http://programminghistorian.org/lessons/sustainable-authorship-in-plain-text-using-pandoc-and-markdown&quot;&gt;Sustainable Authorship in Plain Text using Pandoc and Markdown&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That lesson focuses on using Pandoc to convert from Markdown into other formats, but Pandoc is also able to turn HTML to Markdown, which is what we wanted to do. It can even locate metadata in the HTML, such as the author, title, and date, and convert it into a &lt;a href=&quot;http://jekyllrb.com/docs/frontmatter/&quot;&gt;YAML metadata block&lt;/a&gt; in the Markdown output that Jekyll will recognize.&lt;/p&gt;

&lt;p&gt;But Pandoc needs some help to do this. For example, it expects to find metadata in &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags that look like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Caleb McDaniel&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;author&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Data Mining the Internet Archive Collection&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;03-03-2014&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;date&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;William J Turkel&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;reviewers&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And if you want Pandoc to put that information into a YAML block when converting to Markdown, then those tags have to be located between the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;/head&amp;gt;&lt;/code&gt; tags of the HTML document. &lt;/p&gt;

&lt;p&gt;This deepened our challenge, however, because our original HTML files did not place metadata like author and title inside &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags. Here&amp;rsquo;s an example of how the metadata above appeared in the &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/original_html/data-mining-the-internet-archive.html&quot;&gt;original HTML&lt;/a&gt; downloaded from our Wordpress site:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;article&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;header&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;kicker&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;March 3, 2014&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://programminghistorian.org/lessons/data-mining-the-internet-archive&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Data Mining the Internet Archive Collection&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;byline&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;By Caleb McDaniel&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;credits&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;technical-reviewer&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Technical Reviewer: William J Turkel&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, before we could use Pandoc to convert that HTML to Markdown, we needed to modify the HTML to look more like the &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; examples above. And to do that, we used a Python library called Beautiful Soup, which was explained by Jeri Wieringa in her lesson, &lt;a href=&quot;http://programminghistorian.org/lessons/intro-to-beautiful-soup&quot;&gt;Intro to Beautiful Soup&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In that lesson, Wieringa focused on the power of Beautiful Soup to &amp;ldquo;pull particular content from a webpage&amp;rdquo; by extracting it from particular tags. In the example above, we could use a snippet of code that looks something like this to get the content of the &lt;code&gt;&amp;lt;p class=&amp;quot;byline&amp;quot;&amp;gt;By Caleb McDaniel&amp;lt;/p&amp;gt;&lt;/code&gt; tag:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;soup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeautifulSoup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;soup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;class_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;byline&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Note that this code snippet assumes we have already used the standard Python techniques for &lt;a href=&quot;http://programminghistorian.org/lessons/working-with-text-files#reading-from-a-text-file&quot;&gt;reading from a text file&lt;/a&gt; to get our original HTML from a file and assign it to the variable &lt;code&gt;html&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Beautiful Soup can do more than just help us to &lt;em&gt;find&lt;/em&gt; content in HTML, however; it can also be used to modify the HTML tree. For example, a code snippet that looks something like the below would (1) save all the content from the original &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tag, (2) create a new &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tag that contains the content from our &lt;code&gt;author&lt;/code&gt; variable, but with the leading &lt;code&gt;By&lt;/code&gt; stripped out; and (3) insert that new &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tag into the original &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tag:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;original_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;soup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;author_tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;soup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;meta&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;author_tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;author&amp;#39;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;author_tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;content&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lstrip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;By &amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;original_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;author_tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can follow a similar two-step procedure (find the metadata in the original HTML, and then move it to a tag where Pandoc will be able to recognize it &lt;em&gt;as&lt;/em&gt; metadata) to modify the way that the lesson date, reviewers, and title are stored in the HTML document. We also can and did use Beautiful Soup to make other modifications to the HTML in preparation for Pandoc conversion, such as locating and discarding (or &amp;ldquo;decomposing,&amp;rdquo; in the language of Beautiful Soup) the comments section on old posts.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/prep_for_pandoc.py&quot;&gt;This script&lt;/a&gt; shows all the changes we eventually made in this way. (See the comment lines to get a sense of what each part of the script does.) After running that script on our folder of &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/master/original_html&quot;&gt;original HTML&lt;/a&gt; pages downloaded from our Wordpress site, we had a new folder of &lt;a href=&quot;https://github.com/programminghistorian/jekyll/tree/master/modified_html&quot;&gt;modified HTML files&lt;/a&gt; that was ready (or at least readier) to be fed into Pandoc for conversion into Markdown files.&lt;/p&gt;

&lt;h2 id=&quot;converting-our-modified-html-to-markdown&quot;&gt;Converting Our Modified HTML to Markdown&lt;/h2&gt;

&lt;p&gt;Pandoc can convert an HTML file to Markdown with one simple command:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pandoc -f html -t markdown data-mining-the-internet-archive.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But in our case, the conversion was not quite so simple. Consider what happens if you run that command on &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/modified_html/data-mining-the-internet-archive.html&quot;&gt;one of our modified HTML files&lt;/a&gt;. You would get a Markdown file that begins like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Lesson Goals
------------

The collections of the [Internet Archive](http://archive.org/) (IA)
include many digitized sources of interest to historians, including
[early JSTOR journal content](https://archive.org/details/jstor_ejc),
[John Adams&amp;#39;s personal
library](https://archive.org/details/johnadamsBPL), and the [Haiti
collection](https://archive.org/details/jcbhaiti) at the John Carter
Brown Library. In short, to quote Programming Historian [Ian
Milligan](http://activehistory.ca/2013/09/the-internet-archive-rocks-or-two-million-plus-free-sources-to-explore/),
&amp;quot;The Internet Archive rocks.&amp;quot;

In this lesson, you&amp;#39;ll learn how to download files from such collections
using a Python module specifically designed for the Internet Archive.
You will also learn how to use another Python module designed for
parsing MARC XML records, a widely used standard for formatting
bibliographic metadata.

For demonstration purposes, this lesson will focus on working with the
digitized version of the [Anti-Slavery
Collection](http://archive.org/details/bplscas) at the Boston Public
Library in Copley Square. We will first download a large collection of
MARC records from this collection, and then use Python to retrieve and
analyze bibliographic information about items in the collection. For
example, by the end of this lesson, you will be able to create a list of
every named place from which a letter in the antislavery collection was
written, which you could then use for a mapping project or some other
kind of analysis.

For Whom Is This Useful?
------------------------

This intermediate lesson is good for users of the Programming Historian
who have completed general lessons on downloading files and performing
text analysis on them, but would like an applied example of these
principles. It will also be of interest to historians or archivists who
work with the MARC format or the Internet Archive on a regular basis.

Before You Begin
----------------

We will be working with two Python modules that are not included in
Python&amp;#39;s standard library.

The first,
[internetarchive](https://pypi.python.org/pypi/internetarchive),
provides programmatic access to the Internet Archive. The second,
[pymarc](https://pypi.python.org/pypi/pymarc/), makes it easier to parse
MARC records.

The easiest way to download both is to use pip, the python package
manager. Begin by installing pip using [this Programming Historian
lesson](http://programminghistorian.org/lessons/installing-python-modules-pip/).
Then issue these commands at the command line: To install
internetarchive:

``` {.bash}
sudo pip install internetarchive
```

To install pymarc:

``` {.bash}
sudo pip install pymarc
```

Now you are ready to go to work!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pandoc has converted our links and codeblocks into Markdown syntax, and eliminated a lot of the unnecessary content from the beginning of our HTML file. But right away, we can notice two things that make this Markdown conversion imperfect. First, despite all the work that we did to capture the author, title, and date from the original HTML, that metadata does not appear in this output.&lt;/p&gt;

&lt;p&gt;A less obvious problem appears in the way that Pandoc has rendered code blocks&amp;mdash;by surrounding the code with two lines of three backticks, the first of which also contains the language in curly braces. This is what Pandoc calls a &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#fenced-code-blocks&quot;&gt;fenced code block&lt;/a&gt;. Its purpose is to allow keywords in the code to be highlighted with appropriate colors, as you can see in many Programming Historian lessons. But Jekyll, the engine that powers GitHub Pages, does not recognize fenced code blocks that are formatted in this way.&lt;/p&gt;

&lt;p&gt;There are actually other, even &lt;em&gt;less&lt;/em&gt; obvious problems with the default Markdown conversion that Pandoc produced, but I&amp;rsquo;ll focus on these two. The fixes for them illustrate Pandoc&amp;rsquo;s power and the general principles we used to improve our bulk conversion workflow.&lt;/p&gt;

&lt;h3 id=&quot;preserving-document-metadata&quot;&gt;Preserving Document Metadata&lt;/h3&gt;

&lt;p&gt;First, let&amp;rsquo;s consider the lack of metadata in our Markdown output. Recall that we did a lot of work with Beautiful Soup to create &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags for title, reviewer, author, and date. We hoped that Pandoc would pick up that information from the modified HTML and put into our converted Markdown file, ideally as a YAML front matter block that could be recognized by Jekyll. So what happened?&lt;/p&gt;

&lt;p&gt;The short answer is that we needed to add two more things to our Pandoc command. The first is the &lt;code&gt;--standalone&lt;/code&gt; option, which is described on the &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html&quot;&gt;Pandoc User&amp;rsquo;s Guide&lt;/a&gt; page.&lt;/p&gt;

&lt;p&gt;By default, Pandoc outputs &amp;ldquo;snippets&amp;rdquo;; it focuses on converting the input text into the output format. In most cases, the metadata of the original document doesn&amp;rsquo;t affect that conversion, so Pandoc simply ignores it. In the case of HTML, Pandoc&amp;rsquo;s default behavior is to convert what is between the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tags into your desired output format, and simply ignore what was between the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;

&lt;p&gt;One of the things that the &lt;code&gt;--standalone&lt;/code&gt; option does is to override that default, and instead capture any header and metadata information so that it can be put into the output document. So we should have run this Pandoc command instead of the one above:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pandoc -f html -t markdown --standalone data-mining-the-internet-archive.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At first glance, it still won&amp;rsquo;t look like that command made a difference. You&amp;rsquo;ll get what seems to be the same Markdown output, with no metadata.&lt;/p&gt;

&lt;p&gt;Behind the scenes, however, Pandoc is grabbing the metadata we stored in our &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags and assigning them to Pandoc template variables based on the &lt;code&gt;name&lt;/code&gt; attribute of these tags: for example, &lt;code&gt;author&lt;/code&gt;, &lt;code&gt;reviewers&lt;/code&gt;, and &lt;code&gt;title&lt;/code&gt;. (If you really want to understand what&amp;rsquo;s going on under the hood, try running the above command, with and without the &lt;code&gt;--standalone&lt;/code&gt; option, but changing &lt;code&gt;-t markdown&lt;/code&gt; to &lt;code&gt;-t native&lt;/code&gt;. Even without understanding the output you see, you can compare the first lines of the native output for a standalone document with the first lines of output without the standalone option. Notice that with standalone, something that looks like our metadata appears in the native output.)&lt;/p&gt;

&lt;p&gt;In short, &lt;code&gt;--standalone&lt;/code&gt; has captured the metadata we wanted and assigned it to variables. but we also need to tell Pandoc &lt;em&gt;where&lt;/em&gt; to &lt;em&gt;put&lt;/em&gt; that metadata in our output. To do that, we used a &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#templates&quot;&gt;custom Pandoc template&lt;/a&gt; that looked like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;---
title: $title$
author: $for(author)$$author$$sep$, $endfor$
date: $date$
reviewers: $reviewers$
---

$body$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can read more about &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#templates&quot;&gt;templates&lt;/a&gt; in the Pandoc documentation, but the important thing to note here is that we are telling Pandoc where to output our metadata variables (represented by words with dollar signs around them, like &lt;code&gt;$title$&lt;/code&gt;) and where to output the main body of the HTML file (represented by the &lt;code&gt;$body$&lt;/code&gt; variable). The words that are not wrapped in dollar signs in our template will pass literally into our output document. &lt;/p&gt;

&lt;p&gt;We can save that template in a file called &lt;code&gt;jekyll.md&lt;/code&gt; and then add the option &lt;code&gt;--template=jekyll.md&lt;/code&gt; to our Pandoc command above, like so:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pandoc -f html -t markdown --standalone --template=jekyll.md data-mining-the-internet-archive.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we do, the start of our Markdown output should now look like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;---
title: Data Mining the Internet Archive Collection
author: Caleb McDaniel
date: 03-03-2014
reviewers: William J Turkel
---

Lesson Goals
------------

The collections of the [Internet Archive](http://archive.org/) (IA)
include many digitized sources of interest to historians, including
[early JSTOR journal content](https://archive.org/details/jstor_ejc),
[John Adams&amp;#39;s personal
library](https://archive.org/details/johnadamsBPL), and the [Haiti
collection](https://archive.org/details/jcbhaiti) at the John Carter
Brown Library. In short, to quote Programming Historian [Ian
Milligan](http://activehistory.ca/2013/09/the-internet-archive-rocks-or-two-million-plus-free-sources-to-explore/),
&amp;quot;The Internet Archive rocks.&amp;quot;

In this lesson, you&amp;#39;ll learn how to download files from such collections
using a Python module specifically designed for the Internet Archive.
You will also learn how to use another Python module designed for
parsing MARC XML records, a widely used standard for formatting
bibliographic metadata.

For demonstration purposes, this lesson will focus on working with the
digitized version of the [Anti-Slavery
Collection](http://archive.org/details/bplscas) at the Boston Public
Library in Copley Square. We will first download a large collection of
MARC records from this collection, and then use Python to retrieve and
analyze bibliographic information about items in the collection. For
example, by the end of this lesson, you will be able to create a list of
every named place from which a letter in the antislavery collection was
written, which you could then use for a mapping project or some other
kind of analysis.

For Whom Is This Useful?
------------------------

This intermediate lesson is good for users of the Programming Historian
who have completed general lessons on downloading files and performing
text analysis on them, but would like an applied example of these
principles. It will also be of interest to historians or archivists who
work with the MARC format or the Internet Archive on a regular basis.

Before You Begin
----------------

We will be working with two Python modules that are not included in
Python&amp;#39;s standard library.

The first,
[internetarchive](https://pypi.python.org/pypi/internetarchive),
provides programmatic access to the Internet Archive. The second,
[pymarc](https://pypi.python.org/pypi/pymarc/), makes it easier to parse
MARC records.

The easiest way to download both is to use pip, the python package
manager. Begin by installing pip using [this Programming Historian
lesson](http://programminghistorian.org/lessons/installing-python-modules-pip/).
Then issue these commands at the command line: To install
internetarchive:

``` {.bash}
sudo pip install internetarchive
```

To install pymarc:

``` {.bash}
sudo pip install pymarc
```

Now you are ready to go to work!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that our metadata is now inserted in the output as a &lt;a href=&quot;http://jekyllrb.com/docs/frontmatter/&quot;&gt;Jekyll metadata block&lt;/a&gt;. Hooray!&lt;/p&gt;

&lt;h3 id=&quot;converting-code-block-syntax&quot;&gt;Converting Code Block Syntax&lt;/h3&gt;

&lt;p&gt;The other problem we identified with our Markdown output&amp;mdash;the way to mark fenced code blocks&amp;mdash;remains to be solved, however. This problem was a bit trickier to solve, because Jekyll&amp;rsquo;s default Markdown parser does not recognize code blocks fenced with backticks at all. But &lt;a href=&quot;https://github.com/programminghistorian/jekyll/issues/2&quot;&gt;after some experimentation&lt;/a&gt;, we discovered that we could configure Jekyll to recognize and highlight code blocks that look like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;``` bash
sudo pip install pymarc
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pandoc, as we&amp;rsquo;ve seen, was wrapping &lt;code&gt;bash&lt;/code&gt; in curly braces and a period, like so: &lt;code&gt;{.bash}&lt;/code&gt;. That&amp;rsquo;s because by default, Pandoc is taking the &lt;code&gt;class&lt;/code&gt; attribute in &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/modified_html/data-mining-the-internet-archive.html#L50&quot;&gt;this line&lt;/a&gt; of our HTML and then putting it in braces. If there were more than one &lt;code&gt;class&lt;/code&gt; attribute in that line, Pandoc would continue putting them, prefaced by a period, inside those curly braces, as described in &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#fenced-code-blocks&quot;&gt;the documentation&lt;/a&gt; under &lt;code&gt;Extension: fenced_code_attributes&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;Fortunately, in this case we have a simpler solution than before, because Pandoc provides a command-line option for turning off this behavior. And once that behavior&amp;mdash;or &amp;ldquo;extension&amp;rdquo;&amp;mdash;is turned off, the documentation tells us what will happen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the &lt;code&gt;fenced_code_attributes&lt;/code&gt; extension is disabled, but input contains class attribute(s) for the codeblock, the first class attribute will be printed after the opening fence as a bare word.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In plainer English, that&amp;rsquo;s exactly what we want to produce fenced code blocks that Jekyll can, with some configuration, recognize! So, following the documentation for &lt;a href=&quot;http://johnmacfarlane.net/pandoc/README.html#general-options&quot;&gt;Pandoc&amp;rsquo;s general options&lt;/a&gt;, we modified our Pandoc command again to disable the &lt;code&gt;fenced_code_attributes&lt;/code&gt; extension, like so:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pandoc -f html -t markdown-fenced_code_attributes --standalone --template=jekyll.md data-mining-the-internet-archive.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Run that command on the same &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/modified_html/data-mining-the-internet-archive.html&quot;&gt;modified HTML file&lt;/a&gt; we&amp;rsquo;ve been using above, and the new Markdown output should begin like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;---
title: Data Mining the Internet Archive Collection
author: Caleb McDaniel
date: 03-03-2014
reviewers: William J Turkel
---

Lesson Goals
------------

The collections of the [Internet Archive](http://archive.org/) (IA)
include many digitized sources of interest to historians, including
[early JSTOR journal content](https://archive.org/details/jstor_ejc),
[John Adams’s personal
library](https://archive.org/details/johnadamsBPL), and the [Haiti
collection](https://archive.org/details/jcbhaiti) at the John Carter
Brown Library. In short, to quote Programming Historian [Ian
Milligan](http://activehistory.ca/2013/09/the-internet-archive-rocks-or-two-million-plus-free-sources-to-explore/),
“The Internet Archive rocks.”

In this lesson, you’ll learn how to download files from such collections
using a Python module specifically designed for the Internet Archive.
You will also learn how to use another Python module designed for
parsing MARC XML records, a widely used standard for formatting
bibliographic metadata.

For demonstration purposes, this lesson will focus on working with the
digitized version of the [Anti-Slavery
Collection](http://archive.org/details/bplscas) at the Boston Public
Library in Copley Square. We will first download a large collection of
MARC records from this collection, and then use Python to retrieve and
analyze bibliographic information about items in the collection. For
example, by the end of this lesson, you will be able to create a list of
every named place from which a letter in the antislavery collection was
written, which you could then use for a mapping project or some other
kind of analysis.

For Whom Is This Useful?
------------------------

This intermediate lesson is good for users of the Programming Historian
who have completed general lessons on downloading files and performing
text analysis on them, but would like an applied example of these
principles. It will also be of interest to historians or archivists who
work with the MARC format or the Internet Archive on a regular basis.

Before You Begin
----------------

We will be working with two Python modules that are not included in
Python’s standard library.

The first,
[internetarchive](https://pypi.python.org/pypi/internetarchive),
provides programmatic access to the Internet Archive. The second,
[pymarc](https://pypi.python.org/pypi/pymarc/), makes it easier to parse
MARC records.

The easiest way to download both is to use pip, the python package
manager. Begin by installing pip using [this Programming Historian
lesson](http://programminghistorian.org/lessons/installing-python-modules-pip/).
Then issue these commands at the command line: To install
internetarchive:

``` bash
sudo pip install internetarchive
```

To install pymarc:

``` bash
sudo pip install pymarc
```

Now you are ready to go to work!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice the difference in the way the two &lt;code&gt;bash&lt;/code&gt; code blocks at the end of that snippet are now formatted. We did it!&lt;/p&gt;

&lt;h2 id=&quot;completing-the-bulk-conversion-from-wordpress&quot;&gt;Completing the Bulk Conversion from Wordpress&lt;/h2&gt;

&lt;p&gt;In the above sections, I&amp;rsquo;ve scratched the surface of what was, even with the help of Pandoc, a big job. In the examples above, we&amp;rsquo;ve looked at only one brief section of &lt;em&gt;one&lt;/em&gt; lesson, and other lessons presented us with new challenges to solve. Making sure that all of our converted Markdown got close to the Markdown that Jekyll required took lots of &lt;a href=&quot;https://github.com/programminghistorian/jekyll/commits/master/lessons&quot;&gt;trial and error&lt;/a&gt; of the sort I&amp;rsquo;ve described. Other Pandoc options had to be enabled or disabled to get our Markdown to look just right, as you can see from &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/process_with_pandoc.sh&quot;&gt;the final script we used to process all of our modified HTML files with Pandoc&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We even used &lt;a href=&quot;https://github.com/programminghistorian/jekyll/blob/master/pandoc_filter.py&quot;&gt;this Python filter&lt;/a&gt; to convert some of the URL paths in our original Markdown to relative paths, which were more suitable for our static website. (Pandoc filters, one of the most powerful ways of extending Pandoc, are described in more detail &lt;a href=&quot;http://johnmacfarlane.net/pandoc/scripting.html&quot;&gt;here&lt;/a&gt;. The problem that they solved in this case could also have been solved with further Beautiful Soup modifications to our original HTML. But the advantage of the filter is that it can be used in the future if we want to change relative links again in all our Markdown lessons.) &lt;/p&gt;

&lt;p&gt;After all that, our bulk conversion process still did not produce pristine Markdown at a single stroke. &lt;a href=&quot;https://github.com/programminghistorian/jekyll/issues/5&quot;&gt;Some of the markup in the original Wordpress site was irretrievably lost&lt;/a&gt; by the conversion process, while other errors in the Markdown had to be &lt;a href=&quot;https://github.com/programminghistorian/jekyll/issues/15&quot;&gt;corrected manually by our editors&lt;/a&gt;. One lesson we learned from the whole process is that there may be no such thing as a &lt;em&gt;totally automated&lt;/em&gt; workflow for converting from a Wordpress site like ours to a Jekyll static site.&lt;/p&gt;

&lt;p&gt;Nonetheless, software like Pandoc and techniques like those taught in our lessons on Wget and Beautiful Soup made a difficult job somewhat easier. The results are now available for you to enjoy on our &lt;a href=&quot;https://github.com/programminghistorian/jekyll&quot;&gt;GitHub Pages static site&lt;/a&gt;. Happy hacking!&lt;/p&gt;
</description>
				<pubDate>Wed, 05 Nov 2014 00:00:00 -0800</pubDate>
				<link>http://programminghistorian.org/posts/how-we-moved-to-github</link>
				<guid isPermaLink="true">http://programminghistorian.org/posts/how-we-moved-to-github</guid>
			</item>
		
			<item>
				<title>New navigation — and some hiccups</title>
				<description>&lt;p&gt;As you may have noticed, we’ve changed the way we’ve structured lessons
on the Programming Historian. We’ve been working to include lessons
about a wider range of topics than our initial all-Python, all-the-time
version, and so we’re experimenting with ways to organize them.&lt;/p&gt;

&lt;p&gt;We still have some kinks to work out with organization and display, and
we really appreciate your patience as we work through them. In the
meantime, by request, here’s a list of the lessons in their original
order:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/your-first-lesson-2&quot;&gt;Your First Lesson&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/viewing-html-files&quot;&gt;Getting Started with Online Sources&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/working-with-files-and-webpages&quot;&gt;Working with Files and Web Pages&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/from-html-to-list-of-words&quot;&gt;From HTML to a List of Words &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/computing-frequencies-2&quot;&gt;Computing Frequencies&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/output-data-as-html-file&quot;&gt;Wrapping Output in HTML&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/keywords-in-context-using-n-grams&quot;&gt;Keywords in Context (KWIC)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/downloading-multiple-records-using-query-strings&quot;&gt;Downloading Multiple Records Using Query Strings &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/automated-downloading-with-wget&quot;&gt;Automated Downloading with Wget&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/topic-modeling-and-mallet&quot;&gt;Getting Started with Topic Modeling and MALLET&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Look for more updates soon as we continue to add lessons and work on our
organizational setup.&lt;/p&gt;
</description>
				<pubDate>Sat, 24 Aug 2013 00:00:00 -0700</pubDate>
				<link>http://programminghistorian.org/jekyll/posts/new-navigation</link>
				<guid isPermaLink="true">http://programminghistorian.org/jekyll/posts/new-navigation</guid>
			</item>
		
			<item>
				<title>New navigation — and some hiccups</title>
				<description>&lt;p&gt;As you may have noticed, we’ve changed the way we’ve structured lessons
on the Programming Historian. We’ve been working to include lessons
about a wider range of topics than our initial all-Python, all-the-time
version, and so we’re experimenting with ways to organize them.&lt;/p&gt;

&lt;p&gt;We still have some kinks to work out with organization and display, and
we really appreciate your patience as we work through them. In the
meantime, by request, here’s a list of the lessons in their original
order:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/your-first-lesson-2&quot;&gt;Your First Lesson&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/viewing-html-files&quot;&gt;Getting Started with Online Sources&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/working-with-files-and-webpages&quot;&gt;Working with Files and Web Pages&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/from-html-to-list-of-words&quot;&gt;From HTML to a List of Words &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/computing-frequencies-2&quot;&gt;Computing Frequencies&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/output-data-as-html-file&quot;&gt;Wrapping Output in HTML&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/keywords-in-context-using-n-grams&quot;&gt;Keywords in Context (KWIC)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/downloading-multiple-records-using-query-strings&quot;&gt;Downloading Multiple Records Using Query Strings &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/automated-downloading-with-wget&quot;&gt;Automated Downloading with Wget&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../lessons/topic-modeling-and-mallet&quot;&gt;Getting Started with Topic Modeling and MALLET&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Look for more updates soon as we continue to add lessons and work on our
organizational setup.&lt;/p&gt;
</description>
				<pubDate>Sat, 24 Aug 2013 00:00:00 -0700</pubDate>
				<link>http://programminghistorian.org/posts/new-navigation</link>
				<guid isPermaLink="true">http://programminghistorian.org/posts/new-navigation</guid>
			</item>
		
			<item>
				<title>Welcome to PH2!</title>
				<description>&lt;p&gt;We’re so excited to launch the Programming Historian 2! This newest
version is updated and fine-tuned, but it also reflects a different,
more distributed and inclusive way of thinking about teaching code. In
addition to a solid set of core Python tutorials, we’re soliciting
material from our friends around the web — all of which will be
peer-reviewed and credited. You’ll be able to use the tutorials
sequentially, but you should also be able to “fork” the lessons,
following paths that suit your interests and the needs of your project.&lt;/p&gt;

&lt;p&gt;What you see now should look pretty familiar if you’ve used the
&lt;a href=&quot;http://niche-canada.org/programming-historian&quot;&gt;original &lt;em&gt;Programming Historian&lt;/em&gt;&lt;/a&gt;. Our core set of tutorials leads
you through the basics of Python, from opening documents to scraping the
web to analyzing a body of text. We’ve got a fresh new look, thanks to
Jeremy Boggs. As the site grows, you’ll see more tutorials, and you’ll
have the opportunity to give feedback and contribute your own ideas.&lt;/p&gt;

&lt;p&gt;I’m personally really excited to be involved with PH2 (as the community
manager). As a scholar myself, I’m keenly aware of the ways that digital
tools and resources have changed the way we do our work. Increasingly,
we’re dealing not with piles of index cards, but with folder after
folder of digital files — not to mention the nagging knowledge that new
sources are appearing all the time. This landscape of data can be
overwhelming, to put it mildly. We always knew that to be a scholar was
to fish in a sea of data, but the proliferation of digital sources makes
the limits of our time and attention painfully clear.&lt;/p&gt;

&lt;p&gt;So PH2 comes along at the right time. Programming can help us find
order, patterns, gaps, and surprises in our sources. It can help us
manage and sort through our data. It can’t do the analysis or close
reading — that will always be our job — but it can help us see things we
may not have noticed otherwise. To program is not to abandon the
humanistic values that drew us to our work, but to see what happens when
we combine the ambiguity and complexity native to the humanities with
the machine logic of programming.&lt;/p&gt;

&lt;p&gt;I’m also excited to be involved with PH2 because it’s important to me
that coding feel open and accessible to everyone, not just the people
who self-identify as geeks or techies. Programming is too much fun to
leave to professionals. You &lt;em&gt;can&lt;/em&gt; do this, even if you don’t think of
yourself as technical, and it’s my firm hope that you feel welcomed and
well-supported as you work through these lessons.&lt;/p&gt;

&lt;p&gt;So dig in, get your hands dirty, and let us know how we can improve the
site. Tell us what confuses you and how we can improve the experience.
In using this resource, you’re joining a community of
scholar-programmers, and we couldn’t be happier to welcome you.&lt;/p&gt;
</description>
				<pubDate>Wed, 27 Jun 2012 00:00:00 -0700</pubDate>
				<link>http://programminghistorian.org/jekyll/posts/welcome-to-ph2</link>
				<guid isPermaLink="true">http://programminghistorian.org/jekyll/posts/welcome-to-ph2</guid>
			</item>
		
			<item>
				<title>Welcome to PH2!</title>
				<description>&lt;p&gt;We’re so excited to launch the Programming Historian 2! This newest
version is updated and fine-tuned, but it also reflects a different,
more distributed and inclusive way of thinking about teaching code. In
addition to a solid set of core Python tutorials, we’re soliciting
material from our friends around the web — all of which will be
peer-reviewed and credited. You’ll be able to use the tutorials
sequentially, but you should also be able to “fork” the lessons,
following paths that suit your interests and the needs of your project.&lt;/p&gt;

&lt;p&gt;What you see now should look pretty familiar if you’ve used the
&lt;a href=&quot;http://niche-canada.org/programming-historian&quot;&gt;original &lt;em&gt;Programming Historian&lt;/em&gt;&lt;/a&gt;. Our core set of tutorials leads
you through the basics of Python, from opening documents to scraping the
web to analyzing a body of text. We’ve got a fresh new look, thanks to
Jeremy Boggs. As the site grows, you’ll see more tutorials, and you’ll
have the opportunity to give feedback and contribute your own ideas.&lt;/p&gt;

&lt;p&gt;I’m personally really excited to be involved with PH2 (as the community
manager). As a scholar myself, I’m keenly aware of the ways that digital
tools and resources have changed the way we do our work. Increasingly,
we’re dealing not with piles of index cards, but with folder after
folder of digital files — not to mention the nagging knowledge that new
sources are appearing all the time. This landscape of data can be
overwhelming, to put it mildly. We always knew that to be a scholar was
to fish in a sea of data, but the proliferation of digital sources makes
the limits of our time and attention painfully clear.&lt;/p&gt;

&lt;p&gt;So PH2 comes along at the right time. Programming can help us find
order, patterns, gaps, and surprises in our sources. It can help us
manage and sort through our data. It can’t do the analysis or close
reading — that will always be our job — but it can help us see things we
may not have noticed otherwise. To program is not to abandon the
humanistic values that drew us to our work, but to see what happens when
we combine the ambiguity and complexity native to the humanities with
the machine logic of programming.&lt;/p&gt;

&lt;p&gt;I’m also excited to be involved with PH2 because it’s important to me
that coding feel open and accessible to everyone, not just the people
who self-identify as geeks or techies. Programming is too much fun to
leave to professionals. You &lt;em&gt;can&lt;/em&gt; do this, even if you don’t think of
yourself as technical, and it’s my firm hope that you feel welcomed and
well-supported as you work through these lessons.&lt;/p&gt;

&lt;p&gt;So dig in, get your hands dirty, and let us know how we can improve the
site. Tell us what confuses you and how we can improve the experience.
In using this resource, you’re joining a community of
scholar-programmers, and we couldn’t be happier to welcome you.&lt;/p&gt;
</description>
				<pubDate>Wed, 27 Jun 2012 00:00:00 -0700</pubDate>
				<link>http://programminghistorian.org/posts/welcome-to-ph2</link>
				<guid isPermaLink="true">http://programminghistorian.org/posts/welcome-to-ph2</guid>
			</item>
		
	</channel>
</rss>